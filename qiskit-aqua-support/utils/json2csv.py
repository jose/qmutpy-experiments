#!/usr/bin/env python
#
# ------------------------------------------------------------------------------
# This script converts a JSON file generated by [Coverage](https://coverage.readthedocs.io/en/coverage-5.5/)
# into a CSV file.
#
# Usage:
# json2csv.py <json file path> <csv file path>
#
# Requirements:
#   - Python >= 3.6.8
#   - [Coverage](https://coverage.readthedocs.io/en/coverage-5.5) >= 5.5
# ------------------------------------------------------------------------------

import os
import sys
import csv
import json
import coverage

if sys.version_info < (3, 6, 8):
    print('The json2csv.py script requires Python >= 3.6.8!')
    exit(1)

if len(sys.argv) != 3:
    print("Usage:\njson2csv.py <json file path> <csv file path>")
    exit(1)

json_file = os.path.abspath(sys.argv[1])
csv_file  = os.path.abspath(sys.argv[2])

fieldnames = [
    'file', 'statement', 'line', 'covered', 'excluded'
]

with open(csv_file, 'w', encoding='utf-8') as csv_file_output:
    csv_output = csv.DictWriter(csv_file_output, fieldnames=fieldnames, delimiter=',', lineterminator='\n')
    csv_output.writeheader()

    with open(json_file) as json_file_input:
        data = json.load(json_file_input)

        files = data['files']
        assert len(files) > 0
        for file in files:
            # The term used by [Coverage](https://coverage.readthedocs.io/en/coverage-5.5)
            # is misleading.  It says it reports lines but in fact reports statements,
            # which are different, i.e., a statement might be composed by several lines
            # of code.
            executed_statements = files[file]['executed_lines']
            missing_statements  = files[file]['missing_lines']
            excluded_statements = files[file]['excluded_lines']
            assert len(executed_statements) + len(missing_statements) + len(excluded_statements) > 0

            # Parse .py file and build a dict of lines/statements, e.g.,
            # { line: statement }
            # {27: 27, 28: 27, 39: 39, 40: 39, 41: 39, 42: 39, 43: 39, 44: 44, ... }
            #
            # Construct object
            python_parser_object = coverage.parser.PythonParser(filename=file)
            # Parse source text to find executable lines, excluded lines, etc
            python_parser_object.parse_source()
            # Helper method to find all lines of code in a given statement
            def find_lines_of_a_given_statement(python_parser_object, statement_number):
                lines = [k for k,v in python_parser_object._multiline.items() if v == statement_number]
                if len(lines) == 0: # given statement is not multiline
                    assert statement_number in python_parser_object.raw_statements
                    lines = [statement_number]
                return(lines)

            for statement in executed_statements:
                executed_lines = find_lines_of_a_given_statement(python_parser_object, statement)
                assert len(executed_lines) > 0
                for line in executed_lines:
                    row = {'file': file, 'statement': statement, 'line': line, 'covered': 1, 'excluded': 0}
                    csv_output.writerow(row)
            for statement in missing_statements:
                missing_lines = find_lines_of_a_given_statement(python_parser_object, statement)
                assert len(missing_lines) > 0
                for line in missing_lines:
                    row = {'file': file, 'statement': statement, 'line': line, 'covered': 0, 'excluded': 0}
                    csv_output.writerow(row)
            for statement in excluded_statements:
                excluded_lines = find_lines_of_a_given_statement(python_parser_object, statement)
                assert len(excluded_lines) > 0
                for line in excluded_lines:
                    row = {'file': file, 'statement': statement, 'line': line, 'covered': 0, 'excluded': 1}
                    csv_output.writerow(row)

# EOF
